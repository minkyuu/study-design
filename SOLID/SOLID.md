## SOLID

Q. 객체지향에 대해 공부를 하다보면 많이 들을 수 있었던 SOLID는 과연 무엇일까요?

>: SOLID는 객체지향 설계를 위한 5개의 원칙으로, 각 원칙의 앞 글자를 조합한 것입니다.

<br>

* Single Responsibility Principle

* Open-Closed Principle

* Liskov Substitution Principle

* Interface Segregation Principle

* Dependency Inversion Principle

<br>

---

### 1. Single Responsibility Principle (단일 책임 원칙, SRP)

>: 각 객체는 "단 하나의 책임만"을 가져야 한다는 원칙


<br>

SRP의 효과

1. SRP를 준수하여 설계를 하게되면 응집도는 높게, 결합도는 낮게 설계할 수 있습니다.

2. 다른 객체의 책임이 변경되더라도 독립적이기 때문에 영향을 받지 않습니다.

<br>

---

### 2. Open-Closed Principle (개방-폐쇄 원칙, OCP)

>: 확장에 대해서는 개방적(Open)이고 수정에 대해서는 폐쇄적(Closed)이어야 한다는 원칙

>: 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어있어야 한다는 원칙

<br>

OCP 지키는 방법

>: 변화하는 부분을 추상화한다!! (이 말의 의미는 디자인 패턴들을 공부하다보면 크게 느낄 수 있을 것입니다)

1. 인터페이스를 이용

2. 상속을 이용

<br>

OCP의 효과

* 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도, 확장을 할 수 있게 만들어 줍니다.


<br>

---

### 3. Liskov Substitution Principle (리스코브 치환 원칙, LSP)

>: 자식 클래스는 언제나 부모 클래스의 역할을 대체할 수 있어야 한다는 원칙

>: 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야 한다는 원칙

>: 상속 시에는 오버라이딩을 피하자! (차라리 새로운 메서드를 만들어 그 안에서 부모 클래스의 메서드를 호출하기!)

<br>

LSP를 지키지 않은 경우의 문제점

* OCP를 위반하게 되므로 기능 확장을 위해 더 많은 부분을 수정해야 합니다.
 

<br>

---

### 4. Interface Segregation Principle (인터페이스 분리 원칙, ISP)

>: 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 설계 원칙

>: SRP는 객체의 단일 책임 <-> ISP는 인터페이스의 단일 책임

<br>

ISP를 지키지 않을 경우의 문제점

1. 구현하지 않아도 되는 기능들을 구현해야만 한다.

> (결국 SRP와 같이 책임의 문제로 가게 된다)

<br>

---

### 5. Dependency Inversion Principle (의존성 역전 원칙, DIP)

>: 객체들은 추상화 레벨이 낮은 클래스보다 추상화 레벨이 높은 클래스와 의존 관계를 맺으며 정보를 주고 받아야 한다는 원칙

<br>

Q. 왜 역전인가???

>: 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계 관계를 끊는 의미의 역전!

<br>


Q. 추상화 레벨이 높다는 말의 의미는?

>: 더 큰 개념의 공통 속성, 기능을 묶어둔 것!

>: 추상화 레벨이 높을수록 변화하기 어렵기 때문에 의존관계를 맺기 좋다.

<br>

Q. 의존 관계란?

>: 의존 대상 B가 변하면(기능 추가, 변경), 그것이 A에 영향을 미치는 관계

>: 파라미터나 리턴 타입에 그 타입이 나오거나 메서드에서 그 타입의 인스턴스를 생성하는 관계를 말하기도 합니다.


<br>

DIP의 효과

1. 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 결합도를 최대한 느슨하게 만들어줍니다.

2. 복잡한 컴포넌트들의 관계를 단순화하고 컴포넌트 간의 커뮤니케이션을 효율적이게 해줍니다.


<br>

Q. 그렇다면 의존성 주입 (DI)는 무엇일까??

>: 클래스 간 의존성을 클래스 "외부"에서 주입하는 것을 의미합니다.

>: 클래스에 대한 의존성의 인터페이스화를 통한 코드 유연성 증대 + 클래스의 인스턴스를 외부에서 생성하여 주입

<br>

---

내용 출처 1 : https://victorydntmd.tistory.com/291

내용 출처 2: https://www.nextree.co.kr/p6960/

OCP : https://steady-coding.tistory.com/378

내용 출처 3(LSP, DIP) : https://velog.io/@kyle/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-SOLID-%EC%9B%90%EC%B9%99-%EC%9D%B4%EB%9E%80

의존성 관련 : https://kotlinworld.com/64
